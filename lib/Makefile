include ../make.inc

OBJ_PATH = object_files

QUDA = libquda.a
QUDA_OBJS = $(OBJ_PATH)/timer.o $(OBJ_PATH)/malloc.o $(OBJ_PATH)/solver.o $(OBJ_PATH)/inv_bicgstab_quda.o		\
	$(OBJ_PATH)/inv_cg_quda.o $(OBJ_PATH)/interface_quda.o $(OBJ_PATH)/util_quda.o			\
	$(OBJ_PATH)/blas_cpu.o $(OBJ_PATH)/color_spinor_field.o					\
	$(OBJ_PATH)/cpu_color_spinor_field.o $(OBJ_PATH)/cuda_color_spinor_field.o $(OBJ_PATH)/dirac.o	\
	$(OBJ_PATH)/lattice_field.o $(OBJ_PATH)/gauge_field.o $(OBJ_PATH)/cpu_gauge_field.o			\
	$(OBJ_PATH)/cuda_gauge_field.o $(OBJ_PATH)/dirac_wilson.o				\
	$(OBJ_PATH)/dirac_twisted_mass.o						\
	$(OBJ_PATH)/tune.o 								\
	$(OBJ_PATH)/dslash_quda.o $(OBJ_PATH)/blas_quda.o $(OBJ_PATH)/face_buffer.o $(OBJ_PATH)/face_mpi.o $(OBJ_PATH)/comm_mpi.o	\
	$(OBJ_PATH)/qudaQKXTM.o $(OBJ_PATH)/arlib.o ${OBJ_PATH}/lanczos.o

# header files, found in include/
QUDA_HDRS = blas_quda.h color_spinor_field.h convert.h	\
	dirac_quda.h dslash_quda.h enum_quda.h 		\
	invert_quda.h quda_internal.h util_quda.h	\
	face_quda.h tune_quda.h comm_quda.h lattice_field.h\
	gauge_field.h double_single.h texture.h	\
	numa_affinity.h misc_helpers.h malloc_quda.h

# These are only inlined into blas_quda.cu
BLAS_INLN = #blas_core.h reduce_core.h

# These are only inlined into cuda_color_spinor_field.cu
CSF_INLN = #pack_spinor.h

# These are only inlined into dslash_quda.cu
DSLASH_INLN = #dslash_constants.h dslash_textures.h \
	io_spinor.h wilson_dslash_def.h \
	tm_dslash_def.h pack_face_def.h \
	read_gauge.h misc_helpers.cu


# files containing complex macros and other code fragments to be inlined,
# found in lib/code_pieces
QUDA_INLN = #check_params.h pack_gauge.h quda_matrix.h 

# files generated by the scripts in lib/generate/, found in lib/dslash_core/
# (The current staggered_dslash_core.h, is by hand.)
QUDA_CORE = # wilson_dslash_fermi_core.h wilson_dslash_dagger_fermi_core.h\
	tm_dslash_fermi_core.h tm_dslash_dagger_fermi_core.h		\
	wilson_dslash_gt200_core.h wilson_dslash_dagger_gt200_core.h 	\
	tm_dslash_gt200_core.h tm_dslash_dagger_gt200_core.h		\
	wilson_dslash_g80_core.h wilson_dslash_dagger_g80_core.h 	\
	tm_dslash_g80_core.h tm_dslash_dagger_g80_core.h		\
	wilson_pack_face_core.h wilson_pack_face_dagger_core.h		

INC += -I../include -Idslash_core -I. -Icode_pieces -Iexternal_libs/gsl-1.15/include -Iexternal_libs/lime-1.3.2/include -I/fhgfs/prometheus/home/khadjiyiannakou/magma-1.5.0/include -I/fhgfs/prometheus/home/khadjiyiannakou/qkxTM/include

HDRS = $(QUDA_HDRS:%=../include/%)
HDRS += $(QUDA_INLN)

CORE = $(QUDA_CORE:%=dslash_core/%)

# various parameters that characterize this build, used by the
# routines in tune.cpp to check basic compatibility of an existing
# tunecache.  In the future, we might consider including actual hashes
# of certain source files.
HASH = \"cpu_arch=$(strip $(CPU_ARCH)),gpu_arch=$(strip $(GPU_ARCH))\"

# limit maximum number of registers in BLAS routines to increase occupancy
ifneq (,$(filter $(strip $(GPU_ARCH)),sm_20 sm_21 sm_30))
  MAXREG =
else
  MAXREG = --maxrregcount=80
endif

all: $(QUDA)


$(QUDA): $(QUDA_OBJS) ../make.inc
	ar cru $@ $(QUDA_OBJS)

gen:
	$(PYTHON) generate/dslash_cuda_gen.py
	$(PYTHON) generate/dw_dslash_cuda_gen.py

clean:
	-rm -f $(OBJ_PATH)/*.o $(QUDA)

$(OBJ_PATH)/tune.o: tune.cpp $(HDRS)
	$(CXX) $(CXXFLAGS) -DQUDA_HASH=$(HASH) $< -c -o $@

$(OBJ_PATH)/blas_quda.o: blas_quda.cu $(HDRS) $(BLAS_INLN)
	$(NVCC) $(NVCCFLAGS) $(MAXREG) $< -c -o $@

$(OBJ_PATH)/cuda_color_spinor_field.o: cuda_color_spinor_field.cu $(HDRS) $(CSF_INLN)
	$(NVCC) $(NVCCFLAGS) $< -c -o $@

$(OBJ_PATH)/dslash_quda.o: dslash_quda.cu $(HDRS) $(DSLASH_INLN) $(CORE)
	$(NVCC) $(NVCCFLAGS) $< -c -o $@

$(OBJ_PATH)/%.o: %.cpp $(HDRS)
	$(CXX) $(CXXFLAGS) $< -c -o $@

$(OBJ_PATH)/%.o: %.cu $(HDRS)
	$(NVCC) $(NVCCFLAGS) $< -c -o $@

.PHONY: all gen clean
